https://www.youtube.com/watch?v=8uiZC0l4Ajw&list=PLmPL-f-MSjiJH6X5K0Li1VTZxkE3y4DCc&index=12

gofmt -w yourfile.go >>to format your code(for better readability)

go mod init go_tutotrials

Compiling means:

Translating your human-readable Go code (.go files) into a binary (machine code) that your computer can execute.
This is done by the Go compiler (go build, go run uses it behind the scenes).
Compiler responsibilities:
Checks your code for syntax, type, and logical errors.

Translates your code into machine-executable form (a binary).

Performs optimizations for performance.

Once compilation succeeds, the binary is passed to the runtime to execute

Runtime refers to:

The period when the compiled program is actually running (being executed by the CPU).

Go’s runtime system handles:

Goroutine scheduling

Garbage collection (memory management)

Stack growth

Panic/recover behavior

Maps, slices, channels
Go panics on many runtime errors — you can recover using defer + recover().

A panic in Go is when something goes wrong at runtime and the program immediately stops normal execution.

What is recover()?
recover() is a built-in function that lets you catch a panic and stop it from crashing the program.

But — you can only use recover() inside a defer function.




by google .
g0 -complied
go> interpreted,dynamically typed(python) + efficiency and safety of statically
typed,complied(c++)
- network,multi core computing,concurrency
server side,backend
compliles into single binary>>go build hello.go

modularization
============
go mod init myproject

go>>indentation does NOT matter,but indent to look good

data types
=======
int ,int8 ,int16 etc
float
string ,"string"
bool,true ,false


static typed
=====
data types used incorrectly throws error,c++ ,java 
better proerfomance,bugs can be caught by complier,better data integirty

dynamically typed(weekly,loosely typed)
=======
complier does not enforce data types,python,javascript 
faster to write code,less rigid

variables
=========
statically types

var s string = "hello"
or 
s:= "hello"

var i int = 100



go mod init myproject


Use **fmt.Printf** when you want to use format specifiers like %v (value) and %T (type).

**fmt.Println** just prints values with a space and newline, without interpreting format specifiers.


var grades [3] int = [3] int {10,20,30}
or 
grades := [3] int {10,20,30}


:= → Declare + Assign
func main() {
	name := "Narendra" // declares 'name' and assigns value
	age := 24           // declares 'age' and assigns value
	fmt.Println(name, age)
}


= → Just Assign
func main() {
	name := "Narendra"
	name = "Naren" // reassigns existing variable
	fmt.Println(name)
}


... (ellipsis) in Go
➤ Meaning: It has two main uses
1️⃣ When passing variadic parameters
func greet(names ...string) {
	for _, name := range names {
		fmt.Println("Hello", name)
	}
}

func main() {
	greet("Alice", "Bob", "Charlie")
}
Here, names ...string means you can pass any number of strings, like an array.

2️⃣ When expanding a slice into arguments
func sum(nums ...int) {
	total := 0
	for _, n := range nums {
		total += n
	}
	fmt.Println("Total:", total)
}

func main() {
	numbers := []int{1, 2, 3, 4}
	sum(numbers...) // '...' expands the slice into individual arguments
}


A higher-order function is a function that takes another function as an argument or returns a function.

str := "Hello, World" // valid string
char := 'A'           // valid rune (int32)
Go: double quotes for strings, single quotes for characters/runes.

Python: either works for strings.


How range works with a map in Go:
In Go, range is used in a for loop to iterate over elements in various data structures like slices, arrays, strings, and maps.

When you use range on a map, it gives you keys (by default), or both key and value if you ask for them.


What is sync.WaitGroup?
A WaitGroup is a synchronization primitive in Go that:

Tracks goroutines that are running.

Blocks the main program until all tracked goroutines finish.

Uses a counter to know how many goroutines to wait for.
Key Methods:
Method	Purpose
wg.Add(n)	Increments the counter by n (number of goroutines to wait for).
wg.Done()	Decrements the counter by 1 (called when a goroutine finishes).
wg.Wait()	Blocks until the counter reaches 0.

Why defer is Important?
Ensures wg.Done() is called even if the goroutine panics or returns early.

Guarantees cleanup, similar to try-finally in other languages.

Execution Flow (Fixed):
wg.Add(2) → Counter = 2.

printLine1() → defer wg.Done() → Counter = 1 when it exits.

printLine2() → defer wg.Done() → Counter = 0 when it exits.

wg.Wait() now unblocks because counter reached 0.